<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [C++ 多线程基础](#c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80)
    - [1. 基本概念](#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
    - [2. C++11 多线程库 \<thread\>](#2-c11-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%93-%5Cthread%5C)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# C++ 多线程基础


### 1. 基本概念
1. 并行和并发
    - __并发__ 同一时间段内交替运行多个线程（对于单核CPU，其实是伪并行）。
    - __并行__ 同一时刻运行多个线程，只有多CPU才支持。

2. 同步和异步
    - __异步__ 当几个线程并发执行时，如果不加任何干预措施，那么它们的执行顺序是由系统环境决定的，所以不同时间，不同环境下运行的顺序不保证相同，这就是异步（有差异的步骤）。
    - __同步__ 通过一定的措施，使几个线程或者进程总是按照一定顺序来执行。

3. 阻塞与非阻塞
    - __阻塞__ 当某一个进程或线程请求某一资源而不得，如I/O，便会进入阻塞状态等待。例如 scanf() 函数，当程序运行到 scanf() 时，如果istream buffer 为空，那么程序会进入阻塞状态一直等待输入，这就是以阻塞方式调用 scanf().
    - __非阻塞__ 通过一定方法，可以将 scanf() 编程非阻塞的方式来执行。

    - 所以，__同步即阻塞__。因为需要按某个特定顺序执行，在上一个过程完成之前下一个过程必须等待，就阻塞在了这个地方。
    - 相反的，__异步即非阻塞__。当异步调用某个函数时，函数会立刻返回，而不会阻塞在那。至于如何判断异步操作是否已经完成，通常有三种方式：
        - 状态：异步操作完成时会将某个全局变量设为特定值，可以通过轮询这个变量的值来确定操作是否完成。
        - 通知：异步操作完成会给调用者发送特定信号。
        - 回调：异步操作完成时会调用回调函数。

4. 线程安全相关概念
    - 线程安全可以简单理解为一个方法或者实例可以在多线程中使用而不会出现问题。也就是说在确保多线程执行程序的时候，程序还能按照预期行为去执行。
    - 例如：
        ```cpp
        int count = 0;

        void addCount(){
            count++;
            std::cout << count << endl;
        }
        ```
        这个程序就不是线程安全的，因为在多线程情况下，有可能一个线程A读取了count的值，还没来得及操作，就被切换到另一个线程B，这时线程B读取到了跟线程A同样的值，将 count 写为 count + 1，而程序再切换回线程A时，线程A也会把 count 写为 count + 1，从而覆盖了线程B的写操作。（其实相当于 脏写）。

    - __竞态条件__  
         当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在 __竞态条件__。（如上边的例子） 导致竞态条件发生的代码区称为 __临界区__，上边例子的 addCount() 函数就是一个临界区。

    - __共享资源__  
        允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件。当多个线程同时更新共享资源时会引发竞态条件。因此，需要知道在多线程执行时共享了哪些资源。

    - __局部变量__  
        局部变量存储在线程自己的栈内存中，局部变量永远不会被多个线程共享。所以基础类型的局部变量是线程安全的。但是如果是局部变量的指针或引用，即存放在堆内存中的变量则不一定是线程安全的，因为一个堆内存中的变量可能同时被多个指针所指。

    - __判断资源是否线程安全__  
        如果一个资源的创建，使用，销毁都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。

5. __共享资源的管理__ 和 __线程间的通信__ 是多线程编程的两大核心。


### 2. C++11 多线程库 \<thread\>

1. 一个简单示例：
    ```cpp
    #include <iostream>
    #include <thread>

    using namespace std;

    void output(int i){
        cout << i << endl;
    }

    int main(){
        for(int i = 0; i < 4; i++){
            thread t(output, i);
            t.detach();
        }
        
        return 0;
    }

    ```
    使用如下命令编译：
    >g++ -std=c++11 -o test main.cpp

    输出:
    ```
    1
    0
    23

    ```

    这里可以看到，发生了对输出屏幕(控制台)的资源竞争。假设四个进程编号t0,t1,t2,t3. 
    - 首先，t1拥有控制台，输出1和换行，然后t1线程完成执行
    - 然后，t0拥有控制台，输出0和换行，t0线程完成执行
    - t2拥有控制台，输出2，但是这时控制台所有权转移到t3，t3输出3
    - 然后输出两个线程输出两个换行符，这里的先后顺序不明确。
    
2. 线程管理
    - 每个应用程序至少有一个主线程，除了主线程外，一个进程中还可以创建多个线程，每个线程都需要一个函数入口，入口函数返回退出，线程也会退出。主线程就是以 main 函数作为入口函数的线程。

    - 启动一个线程  
        ```cpp
        do_task();
        
        std::thread t(do_task);
        ```
        只要创建一个 std::thread 对象，就会启动给一个线程，并使用该对象来管理该线程。除了传入函数外，还可以传入 lambda 表达式，或重载了 () 运算符的类（只要是可调用类型就可以）。

    - 当线程启动后，一定要在和线程相关联的线程对象销毁前，确定以何种方式等待线程执行结束。__C++11提供两种方式等待线程结束__：
        - __detach 方式（非阻塞）__，启动的线程在后台自主运行，当前代码继续往下执行，不等待新线程执行结束。
        - __join 方式 （阻塞）__，等待启动的线程执行完成，才会继续往下执行。

        - 无论以何种方式，一定要在线程对消被销毁前调用 t.join() 或 t.thread()，来决定线程以何种方式运行。对于非阻塞方法，需要特别注意：__创建的新线程对当前作用域的变量的使用__，创建新线程的作用域结束后，该线程可能仍在执行，这时局部变量随着作用域的结束已经销毁，如果线程继续使用那些局部变量的引用或指针，会出现错误。

        - join() 可以被设置用来实现 __同步功能__，如果在主线程调用了 join()，那么在子线程终止前主线程会一直阻塞等待子线程执行完毕，这样就可以用来同步子线程和主线程。

3. 线程的两种状态
    - __joinable: 可会合的__
    - __detachable: 分离的(不可会合的)__
    - 一个子线程被创建后默认为 joinable，在子线程终止前需要调用 join() 函数来将其与父线程会合，只有这样在子线程终止后才能被摧毁，占用的资源才会被释放 。 也可以用 detach() 将其设置为分离的，一个线程分离后就不再受控制，在后台自动运行，当其终止的时候回马上被摧毁。可以用 joinable() 方法来检验当前线程是否为 joinable.

3. 异常情况下等待线程完成
    - 当使用 detach 方式让线程在后台运行时，即使线程出现异常被销毁，仍能保持线程在后台运行。 但是以 join 方式运行时，需要在主线程的合适位置调用 join 函数，如果 join 之前出现了异常，thread 被销毁，线程就会被异常所中介。为了避免异常将线程终结，或者要保证线程在函数退出前完成，就要保证要在函数退出前调用 join.

    - 一种比较好的方法是 __资源获取即初始化(RAII, Resource Acquistion Is Initialization)__，该方法提供一个类，在析构函数中调用 join.
        ```cpp
        class thread_guard{
            thread &t;
        public:
            // 提供构造函数和析构函数
            explicit thread_guard(thread& _t) :
                t(_t){}
            
            ~thread_guard(){
                if (t.joinable())
                    t.join();
            }
            
            // 不提供拷贝构造函数和重载赋值运算符函数
            thread_guard(const thread_guard&) = delete;
            thread_guard& operator=(const thread_guard&) = delete;
        };

        void func(){
            thread t([]{
                cout << "hello" << endl;
            });
            
            thread_guard g(t);
        }
        ```
        这样可以保证无论何种情况，当函数func退出时，系统自动调用局部变量(守卫变量)g的析构函数将其销毁，从而保证 t.join() 一定会被调用。因为就算中途发生异常，g对象的析构函数也一定会被调用。

4. 向线程传递参数
    - 在构造 thread 对象时，依次将参数传入即可：
        ```cpp
        void func(int *a, int n){}

        int buffer[10];
        thread t(func, buffer, 10);
        t.join();
        ```

        注意：即使函数要接收的参数类型是引用，也会将传递的参数以拷贝的方式复制到线程空间。所以，如果要在线程中使用引用更新对象，其引用的是拷贝到线程空间中的对象，而不是初始希望改变的对象。

5. 获取线程的 id
    - 通过 thread 的对象调用 get_id() 获取。
    - 在当前线程调用 this_thread::get_id() 获取。

