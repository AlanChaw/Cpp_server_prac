# 一些 socket 编程的杂项

这里记录一些底层 socket 编程的难以理解的地方，和一些个人总结，当做一个备忘录。


### 1. 关于 TCP socket 的文件描述符

1. Linux socket (Tcp) 接口的简单实用和一些宏定义，参照：https://www.jianshu.com/p/3b233facd6bb。 

2. Tcp socket 对象本身被 Linux 当做一个对象(文件)存放在内核内存中，用户态能拿到的只有指向该 socket 对象的 file descriptor，相当于一个指向 socket 对象的指针。实际上对于用户来说，socket 只是一个特殊的 FD。

3. 对于服务端，当使用 socket() 函数创建了一个 Tcp socket，需要将其绑定(bind)到指定端口，并开启被动模式(listen)。这里又分为阻塞(默认)和非阻塞两种模式：
    - 对于阻塞状态，当前线程会一直阻塞在 accept() 函数上，直到有新连接到来，accept() 会返回新 Tcp 连接的文件描述符。

    - 对于非阻塞状态，当无新连接到来时，调用 accept() 不会阻塞，会立即返回-1，表示没有新连接。这时的处理方法是为该 socket fd 的可读事件（POLLIN）设置回调函数，当该 socket fd 可读时，调用 accept() 获取到新 Tcp 连接的文件描述符。(没有人会用轮询 accept() 这种方法来处理非阻塞Socket IO).

4. 这里需要特别注意的是，新连接创建以后就使用单独的 FD 来代表该新连接，从中可以拿到 对方地址(IP:port) 和 我方本地地址（IP:port）信息。而原来的 socket 在用 accept() 处理完可读事件后仍然负责 listen，与新连接再无任何关系。以后的 接收、发送、断开连接等操作都通过新连接的 FD 来完成。

---

### 2. 关于几层缓存(buffer)

实际上，对于非阻塞网络编程，从底层到上层，数据缓存(buffer)可分为三个必要的层次： 
- __TCP 自身缓存__ 
- __Socket 缓存__
- __应用层缓存__  

这里说一下这三者的关系：

1. TCP 自身缓存，也就是 Tcp 的发送窗口和接收窗口。这一部分对于用户而言是透明的。对于发送窗口，由于流量控制，其会监测接收方的接收窗口，从而控制自身的发送速度。而且一旦发生丢包（出现一次超时或3个冗余的ACK。丢包原因可能由于路由器缓冲溢出、或链路层队列溢出、或链路中断等），Tcp会自动执行重传和拥塞控制。而且，Tcp可能在上层将数据写到其缓冲中时立刻将数据发送到网络，也可能会在自身缓冲中积压一段时间，这里是不受程序员控制的。Tcp 的发送窗口只有当确认数据已被收到时才会将这部分数据丢弃。 所以，对于长连接，数据是以字节流形式到达的（Tcp本质是字节流协议），这就需要应用层手动处理分包。  


2. Socket 缓存，位于 Tcp 缓存和应用层缓存之间，负责向 Tcp 缓存写入数据。
    - 对于发送端，当用户对 Socket fd 执行 send()/write() 操作时，数据只是被写入到 socket 缓存中，当成功写入后，socket 不管数据是否成功发送给对方或发送到网络，都会立即返回。而当 socket 缓存满时，send()/write() 调用会阻塞，直到数据能够被全部写入为止。 当数据被写入到 socket 缓存后，剩下的事情就交给 Tcp 了，Tcp 会将 socket 缓存中的数据逐步读入自身缓存（当有空闲时读入），而且 Tcp 保证数据完整、有序地交付。

    - 对于接收端，当调用 read()/recv() 函数时，也是从 socket 缓存中读取数据，而不是直接从网络读取。

    - Socket IO 缓存还有以下几个特点：
        - 当 Socket 创建时会自动创建，对于每个 Tcp 连接，有其自己的独立缓存
        - 发送方关闭 socket，其发送缓存中的数据也会保证能够交付。
        - 接收方关闭 socket，其接收缓存中的数据会丢失。

3. 应用层缓存。应用层缓存同样包括 output buffer（发送方） 和 input buffer（接收方），是非阻塞网络编程必不可少的。

    - 对于发送方，因为当 socket 缓存已满时，write()调用会阻塞，IO线程这时就无法继续响应和处理其他 socket 的事件。所以，就要求 write() 调用无论何时都能立刻返回，使IO线程能够返回 event loop 的入口，剩下的工作交由其他线程来处理。因此，应用层缓存是必不可少的。

    - 对于接收方，要处理“收到的数据不构成完整消息”和“一次收到两条以上的消息”的情况，不能每次 socket 可写时就去读数据。这就需要接收方将接收到的数据放到 input buffer 中，直到构成一条完整的消息，才通知业务逻辑来处理。

---
### 3. 关于水平触发和边沿触发

1. 水平触发指的是想要关注的是事件的某种状态，当事件一直处于这种状态时会一直触发，例如当socket可写时，reactor会一直收到通知，所以当不需要写时，应停止对socket fd可写事件的关注，避免busy loop。

2. 边沿触发指的是只有当事件的状态发生变化时才会触发，例如当读取socket fd时，要一直读到不可再读为止，这样才能保证下次由不可读变为可读的事件会被触发。

---
### 4. 关于非阻塞IO 和 IO多路复用

1. 非阻塞IO是配合IO多路复用一起使用的，IO多路复用要求线程不能够在IO调用上阻塞，只能在 poll、select、epoll调用上阻塞，这三个调用就是用来实现IO多路复用的，指的是一个线程通过一个 eventloop 能够同时监测多个 fd 的状态，当达成某个状态时通知 epoll，然后由IO线程处理该 fd 上的 IO 操作，IO操作都是在 IO线程进行，一般对于处理业务逻辑的部分会交由其他线程或交由线程池来执行，不在 IO 线程处理计算量大的任务，让 eventloop 尽快回到起点，继续阻塞在 epoll上。


<!-- UDP:https://www.cnblogs.com/skyfsm/p/6287787.html -->
